import streamlit as st
import pandas as pd
import random, time, json, smtplib
from email.mime.text import MIMEText
from pathlib import Path

# ----------------- Config & Helpers -----------------
CONFIG_FILE = "mailtrap_config.json"  # create locally from template and fill credentials

def load_config():
    cfg_path = Path(CONFIG_FILE)
    if not cfg_path.exists():
        st.error(f"Config file '{CONFIG_FILE}' not found. Copy mailtrap_config_template.json -> mailtrap_config.json and edit credentials locally.")
        st.stop()
    return json.loads(cfg_path.read_text())

cfg = load_config()
SMTP_HOST = cfg.get("SMTP_HOST", "sandbox.smtp.mailtrap.io")
SMTP_PORT = cfg.get("SMTP_PORT", 587)
SMTP_USER = cfg.get("SMTP_USER")
SMTP_PASS = cfg.get("SMTP_PASS")
SENDER_EMAIL = cfg.get("SENDER_EMAIL", "cics-monitor@demo.com")
RECEIVER_EMAIL = cfg.get("RECEIVER_EMAIL", "uditrai.10@gmail.com")
THRESHOLD = float(cfg.get("THRESHOLD_SECONDS", 5))

def send_email_mailtrap(txn, category):
    subject = f"Alert: {category} transaction {txn['TransactionID']} in region {txn['Region']}"
    body = f"""Transaction Alert from CICS Monitor

Transaction ID: {txn['TransactionID']}
Region: {txn['Region']}
Status: {txn['Status']}
Response Time: {txn['ResponseTime']} sec
Category: {category}
Timestamp: {time.strftime('%Y-%m-%d %H:%M:%S UTC', time.gmtime())}

This alert was generated by the CICS Transaction Health Monitoring Dashboard.
"""
    msg = MIMEText(body)
    msg['Subject'] = subject
    msg['From'] = SENDER_EMAIL
    msg['To'] = RECEIVER_EMAIL
    try:
        server = smtplib.SMTP(SMTP_HOST, SMTP_PORT, timeout=10)
        server.starttls()
        server.login(SMTP_USER, SMTP_PASS)
        server.send_message(msg)
        server.quit()
        return True, "Email sent"
    except Exception as e:
        return False, str(e)

# ----------------- Load Master Data -----------------
@st.cache_data
def load_master():
    return pd.read_csv("transactions_master.csv")

master_df = load_master()

# ----------------- Page Config & Dark Theme CSS -----------------
st.set_page_config(page_title="CICS Transaction Health Monitoring Dashboard", layout="wide")
# Dark theme via CSS injection
st.markdown(
    """
    <style>
    .reportview-container {background: #0E1117;}
    .stApp {background: #0E1117; color: #FFFFFF;}
    .css-1d391kg {background: #0E1117;}
    .css-1y0tads {background: #0E1117;}
    .stButton>button {background-color:#2E3B4E;color:white;}
    .stDownloadButton>button {background-color:#2E3B4E;color:white;}
    .css-10trblm {color: #FFFFFF;}
    .css-1d391kg p, .css-1d391kg span {color: #FFFFFF;}
    </style>
    """,
    unsafe_allow_html=True,
)

st.title("CICS Transaction Health Monitoring Dashboard")

# ----------------- Sidebar Controls -----------------
st.sidebar.header("Simulation Controls")
sample_size = st.sidebar.slider("Sample size per run", 40, 50, 45)
seed = st.sidebar.number_input("Random seed (0 for random)", value=0, step=1)
threshold = st.sidebar.number_input("Alert threshold (sec)", value=int(THRESHOLD), step=1)
if seed != 0:
    random.seed(int(seed))

# Auto-refresh countdown (JS)
AUTO_REFRESH_SECONDS = 60
countdown_placeholder = st.sidebar.empty()

# ----------------- Sampling Logic: ensure 2-3 anomalies -----------------
def generate_sample(df_master, n, anomalies_min=2, anomalies_max=3, threshold=THRESHOLD):
    # choose n random rows
    sample = df_master.sample(n, replace=True).reset_index(drop=True)
    # ensure anomalies count between min and max
    k = random.randint(anomalies_min, anomalies_max)
    idxs = random.sample(range(len(sample)), k)
    for idx in idxs:
        choice = random.choice(["FAILED", "ABORTED", "LONGRUN"])
        if choice == "LONGRUN":
            sample.at[idx, "ResponseTime"] = round(max(threshold + 0.5, random.uniform(threshold+0.5, threshold+6.0)),2)
            sample.at[idx, "Status"] = "SUCCESS"  # long-running can still be success but slow
        else:
            # failed/aborted - keep response maybe small or random
            sample.at[idx, "Status"] = random.choice(["FAILED","ABORTED"])
            sample.at[idx, "ResponseTime"] = round(random.uniform(0.5, threshold-0.1),2)
    return sample

# ----------------- Generate on load -----------------
if 'sample_df' not in st.session_state or st.session_state.get('regen', True):
    st.session_state['sample_df'] = generate_sample(master_df, sample_size, 2, 3, threshold)
    st.session_state['regen'] = False

# Button to manually regenerate
if st.button("Generate Random Sample Now"):
    st.session_state['sample_df'] = generate_sample(master_df, sample_size, 2, 3, threshold)

sample_df = st.session_state['sample_df']

# ----------------- Category column -----------------
def categorize_row(r, threshold):
    if r["Status"] in ["FAILED", "ABORTED"]:
        return "Failed"
    if r["ResponseTime"] >= threshold:
        return "Long Running"
    return "Normal"

sample_df["Category"] = sample_df.apply(lambda r: categorize_row(r, threshold), axis=1)

# ----------------- Filters -----------------
st.sidebar.subheader("Filters")
regions = st.sidebar.multiselect("Select Region(s)", options=sorted(sample_df["Region"].unique()))
txn_search = st.sidebar.text_input("Transaction prefix (e.g., TN*)")

filtered = sample_df.copy()
if regions:
    filtered = filtered[filtered["Region"].isin(regions)]
if txn_search:
    if txn_search.endswith("*"):
        prefix = txn_search[:-1]
        filtered = filtered[filtered["TransactionID"].str.startswith(prefix)]
    else:
        filtered = filtered[filtered["TransactionID"] == txn_search]

# ----------------- Display -----------------
st.subheader("Sampled Transactions (current run)")
st.dataframe(filtered)

# Summary and charts
st.subheader("Summary")
summary = filtered["Category"].value_counts().rename_axis("Category").reset_index(name="Count")
st.table(summary)

# Bar chart: avg response by region
st.subheader("Average Response Time by Region")
region_group = filtered.groupby("Region")["ResponseTime"].mean().reset_index().sort_values("ResponseTime", ascending=False)
if not region_group.empty:
    st.bar_chart(region_group.set_index("Region"))

# Pie-like chart: status distribution (use bar chart)
st.subheader("Transaction Status Distribution")
status_group = filtered["Category"].value_counts().reset_index() status_group.columns = ['Status', 'Count']
if not status_group.empty:
    st.bar_chart(status_group.set_index("Status"))

# ----------------- Alerts: send email for Failed & Long Running -----------------
st.subheader("Alerts (emails sent this run)")
alerts = []
for _, row in filtered.iterrows():
    cat = row["Category"]
    if cat in ["Failed", "Long Running"]:
        ok, msg = send_email_mailtrap(row, cat)
        alerts.append({"TransactionID": row["TransactionID"], "Region": row["Region"], "ResponseTime": row["ResponseTime"], "Status": row["Status"], "Category": cat, "EmailSent": ok, "Detail": msg})

if alerts:
    alerts_df = pd.DataFrame(alerts)
    st.dataframe(alerts_df)
else:
    st.info("No alerts generated in this run.")

# ----------------- Download current sample -----------------
st.subheader("Download Current Sample")
csv = filtered.to_csv(index=False).encode('utf-8')
st.download_button("Download CSV", data=csv, file_name="sample_transactions.csv", mime="text/csv")

# ----------------- Auto-refresh countdown and reload using JS -----------------
countdown_js = f"""
<div id="countdown" style="color:#BDE0FE; font-weight:600;"></div>
<script>
var seconds = {AUTO_REFRESH_SECONDS};
function updateCountdown() {{
    document.getElementById("countdown").innerText = "Next refresh in: " + seconds + "s";
    if (seconds <= 0) {{
        // reload the page to refresh data
        window.location.reload();
    }} else {{
        seconds -= 1;
        setTimeout(updateCountdown, 1000);
    }}
}}
updateCountdown();
</script>
"""
countdown_placeholder.markdown(countdown_js, unsafe_allow_html=True)
